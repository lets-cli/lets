"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[927],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return u}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(t),u=i,k=d["".concat(c,".").concat(u)]||d[u]||m[u]||r;return t?a.createElement(k,o(o({ref:n},p),{},{components:t})):a.createElement(k,o({ref:n},p))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},1527:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return c},default:function(){return u},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return m}});var a=t(7462),i=t(3366),r=(t(7294),t(3905)),o=["components"],l={id:"architecture",title:"Architecture"},c=void 0,s={unversionedId:"architecture",id:"architecture",title:"Architecture",description:"Architecture diagram",source:"@site/docs/architecture.md",sourceDirName:".",slug:"/architecture",permalink:"/docs/architecture",draft:!1,editUrl:"https://github.com/lets-cli/lets/edit/master/docs/docs/architecture.md",tags:[],version:"current",frontMatter:{id:"architecture",title:"Architecture"},sidebar:"someSidebar",previous:{title:"IDE/Text editors support",permalink:"/docs/ide_support"},next:{title:"Development",permalink:"/docs/development"}},p={},m=[{value:"Parser",id:"parser",level:2},{value:"How parsing works ?",id:"how-parsing-works-",level:3},{value:"Mixins",id:"mixins",level:4},{value:"Validation",id:"validation",level:3},{value:"Env",id:"env",level:3},{value:"Cobra CLI Framework",id:"cobra-cli-framework",level:2},{value:"Binding our config with Cobra",id:"binding-our-config-with-cobra",level:3},{value:"Root command",id:"root-command",level:4},{value:"Subcommands",id:"subcommands",level:4},{value:"Runner",id:"runner",level:2}],d={toc:m};function u(e){var n=e.components,l=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},d,l,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Architecture diagram",src:t(2575).Z,width:"709",height:"312"})),(0,r.kt)("h2",{id:"parser"},"Parser"),(0,r.kt)("p",null,"At the start of lets application, parser tries to find ",(0,r.kt)("inlineCode",{parentName:"p"},"lets.yaml")," file starting from current directory up to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/"),"."),(0,r.kt)("p",null,"When config file is found, parser tries to read/parse and validate yaml config."),(0,r.kt)("h3",{id:"how-parsing-works-"},"How parsing works ?"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"config.go:Config")," struct implements ",(0,r.kt)("inlineCode",{parentName:"p"},"UnmarshalYAML")," function, so when ",(0,r.kt)("inlineCode",{parentName:"p"},"yaml.Unmarshal")," called with ",(0,r.kt)("inlineCode",{parentName:"p"},"Config")," instance passed in,\ncustom unmarshalling code is executed."),(0,r.kt)("p",null,"Its common to make some normalization of commands and its data during parsing phase so the rest of the code\ndoes not have to do any kind of normalization on its own."),(0,r.kt)("p",null,"To add a new field you probably must implement ",(0,r.kt)("inlineCode",{parentName:"p"},"UnmarshalYAML")," somehow."),(0,r.kt)("h4",{id:"mixins"},"Mixins"),(0,r.kt)("p",null,"Lets has feature called ",(0,r.kt)("a",{parentName:"p",href:"/docs/config#mixins"},"mixins"),". When parser meets ",(0,r.kt)("inlineCode",{parentName:"p"},"mixins")," directive,\nit basically repeats all read/parse logic on minix files."),(0,r.kt)("p",null,"Since mixin config files have some limitations, although they are parsed the same way, validation is a bit different."),(0,r.kt)("h3",{id:"validation"},"Validation"),(0,r.kt)("p",null,"There are two validation phases."),(0,r.kt)("p",null,"First validation phase happens during unmarshalling and checks if:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"directives names valid"),(0,r.kt)("li",{parentName:"ul"},"directives types valid (array, map, string, number, etc.)"),(0,r.kt)("li",{parentName:"ul"},"references to command in ",(0,r.kt)("inlineCode",{parentName:"li"},"depends")," directive points to existing commands")),(0,r.kt)("p",null,"Second phase happens after we ensured that config is syntactically and semantically correct."),(0,r.kt)("p",null,"Int the second phase we are checking:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"config version"),(0,r.kt)("li",{parentName:"ul"},"circular dependencies in commands")),(0,r.kt)("h3",{id:"env"},"Env"),(0,r.kt)("p",null,"TODO"),(0,r.kt)("h2",{id:"cobra-cli-framework"},"Cobra CLI Framework"),(0,r.kt)("p",null,"We are using ",(0,r.kt)("inlineCode",{parentName:"p"},"Cobra")," CLI framework and delegating to it most of the work related to parsing\ncommand line arguments, help messages etc."),(0,r.kt)("h3",{id:"binding-our-config-with-cobra"},"Binding our config with Cobra"),(0,r.kt)("p",null,"Now we have to bind our config to ",(0,r.kt)("inlineCode",{parentName:"p"},"Cobra"),"."),(0,r.kt)("p",null,"Cobra has a concept of ",(0,r.kt)("inlineCode",{parentName:"p"},"cobra.Command"),". It is a representation of command in CLI application, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"git commit\ngit pull\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"git")," is a CLI applications and\n",(0,r.kt)("inlineCode",{parentName:"p"},"commit")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"pull")," are commands."),(0,r.kt)("p",null,"In a traditional ",(0,r.kt)("inlineCode",{parentName:"p"},"lets")," application commands will be what is declared in ",(0,r.kt)("inlineCode",{parentName:"p"},"lets.yaml")," commands section."),(0,r.kt)("p",null,"To achieve this we are creating so-called ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," command and ",(0,r.kt)("inlineCode",{parentName:"p"},"subcommands")," from config."),(0,r.kt)("h4",{id:"root-command"},"Root command"),(0,r.kt)("p",null,"Root command is responsible for:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"lets")," own command line flags such as ",(0,r.kt)("inlineCode",{parentName:"li"},"--version"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"--upgrade"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"--help")," and so on."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"lets")," commands autocompletion in terminal")),(0,r.kt)("h4",{id:"subcommands"},"Subcommands"),(0,r.kt)("p",null,"Subcommand is created from our ",(0,r.kt)("inlineCode",{parentName:"p"},"Config.Commands")," (see ",(0,r.kt)("inlineCode",{parentName:"p"},"initSubCommands")," function)."),(0,r.kt)("p",null,"In subcommand's ",(0,r.kt)("inlineCode",{parentName:"p"},"RunE")," callback we are parsing/validation/normalizing command line arguments for this subcommand\nand then finally executing command with ",(0,r.kt)("inlineCode",{parentName:"p"},"Runner"),"."),(0,r.kt)("p",null,"Since we are using ",(0,r.kt)("inlineCode",{parentName:"p"},"docopt")," as an argument parser for subcommands, we don't let ",(0,r.kt)("inlineCode",{parentName:"p"},"Cobra")," parse and interpret args,\nand instead we are passing raw arguments as is to ",(0,r.kt)("inlineCode",{parentName:"p"},"Runner"),"."),(0,r.kt)("h2",{id:"runner"},"Runner"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Runner")," is responsible for:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"parsing and preparing args using ",(0,r.kt)("inlineCode",{parentName:"li"},"docopt")),(0,r.kt)("li",{parentName:"ul"},"calculating and storing command's checksums"),(0,r.kt)("li",{parentName:"ul"},"executing other commands from ",(0,r.kt)("inlineCode",{parentName:"li"},"depends")," section"),(0,r.kt)("li",{parentName:"ul"},"preparing environment "),(0,r.kt)("li",{parentName:"ul"},"running command in OS using ",(0,r.kt)("inlineCode",{parentName:"li"},"exec.Command"))))}u.isMDXComponent=!0},2575:function(e,n,t){n.Z=t.p+"assets/images/lets-architecture-diagram-ac44548f80a96c907e3331fe90c31144.png"}}]);